'use strict';

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var events = _interopDefault(require('events'));
var path = _interopDefault(require('path'));

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x.default : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

const EQQ = /\s|=/;
const FLAG = /^-{1,2}/;
const PREFIX = /^--no-/i;

function isBool(any) {
	return typeof any === 'boolean';
}

function toArr(any) {
	return Array.isArray(any) ? any : any == null ? [] : [any];
}

function toString(any) {
	return any == null || any === true ? '' : String(any);
}

function toBool(any) {
	return any === 'false' ? false : Boolean(any);
}

function toNum(any) {
	let x = Number(any);
	return !isBool(any) && (x * 0 === 0) ? x : any;
}

function getAlibi(names, arr) {
	if (arr.length === 0) return arr;
	let k, i = 0, len = arr.length, vals = [];
	for (; i < len; i++) {
		k = arr[i];
		vals.push(k);
		if (names[k] !== void 0) {
			vals = vals.concat(names[k]);
		}
	}
	return vals;
}

function typecast(key, val, strings, booleans) {
	if (strings.indexOf(key) !== -1) return toString(val);
	if (booleans.indexOf(key) !== -1) return toBool(val);
	return toNum(val);
}

var lib = function(args, opts) {
	args = args || [];
	opts = opts || {};

	opts.string = toArr(opts.string);
	opts.boolean = toArr(opts.boolean);

	const aliases = {};
	let k, i, j, x, y, len, type;

	if (opts.alias !== void 0) {
		for (k in opts.alias) {
			aliases[k] = toArr(opts.alias[k]);
			len = aliases[k].length; // save length
			for (i = 0; i < len; i++) {
				x = aliases[k][i]; // alias's key name
				aliases[x] = [k]; // set initial array
				for (j = 0; j < len; j++) {
					if (x !== aliases[k][j]) {
						aliases[x].push(aliases[k][j]);
					}
				}
			}
		}
	}

	if (opts.default !== void 0) {
		for (k in opts.default) {
			type = typeof opts.default[k];
			opts[type] = (opts[type] || []).concat(k);
		}
	}

	// apply to all aliases
	opts.string = getAlibi(aliases, opts.string);
	opts.boolean = getAlibi(aliases, opts.boolean);

	let idx = 0;
	const out = { _: [] };

	while (args[idx] !== void 0) {
		let incr = 1;
		const val = args[idx];

		if (val === '--') {
			out._ = out._.concat(args.slice(idx + 1));
			break;
		} else if (!FLAG.test(val)) {
			out._.push(val);
		} else if (PREFIX.test(val)) {
			out[val.replace(PREFIX, '')] = false;
		} else {
			let tmp;
			const segs = val.split(EQQ);
			const isGroup = segs[0].charCodeAt(1) !== 45; // '-'

			const flag = segs[0].substr(isGroup ? 1 : 2);
			len = flag.length;
			const key = isGroup ? flag[len - 1] : flag;

			if (opts.unknown !== void 0 && aliases[key] === void 0) {
				return opts.unknown(segs[0]);
			}

			if (segs.length > 1) {
				tmp = segs[1];
			} else {
				tmp = args[idx + 1] || true;
				FLAG.test(tmp) ? (tmp = true) : (incr = 2);
			}

			if (isGroup && len > 1) {
				for (i = len - 1; i--; ) {
					k = flag[i]; // all but last key
					out[k] = typecast(k, true, opts.string, opts.boolean);
				}
			}

			const value = typecast(key, tmp, opts.string, opts.boolean);
			out[key] = out[key] !== void 0 ? toArr(out[key]).concat(value) : value;

			// handle discarded args when dealing with booleans
			if (isBool(value) && !isBool(tmp) && tmp !== 'true' && tmp !== 'false') {
				out._.push(tmp);
			}
		}

		idx += incr;
	}

	if (opts.default !== void 0) {
		for (k in opts.default) {
			if (out[k] === void 0) {
				out[k] = opts.default[k];
			}
		}
	}

	for (k in out) {
		if (aliases[k] === void 0) continue;
		y = out[k];
		len = aliases[k].length;
		for (i = 0; i < len; i++) {
			out[aliases[k][i]] = y; // assign value
		}
	}

	return out;
};

var utils = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeBrackets = (v) => v.replace(/[<[].+/, '').trim();
exports.findAllBrackets = (v) => {
    const ANGLED_BRACKET_RE_GLOBAL = /<([^>]+)>/g;
    const SQUARE_BRACKET_RE_GLOBAL = /\[([^\]]+)\]/g;
    const res = [];
    const parse = (match) => {
        let variadic = false;
        let value = match[1];
        if (value.startsWith('...')) {
            value = value.slice(3);
            variadic = true;
        }
        return {
            required: match[0].startsWith('<'),
            value,
            variadic
        };
    };
    let angledMatch;
    while ((angledMatch = ANGLED_BRACKET_RE_GLOBAL.exec(v))) {
        res.push(parse(angledMatch));
    }
    let squareMatch;
    while ((squareMatch = SQUARE_BRACKET_RE_GLOBAL.exec(v))) {
        res.push(parse(squareMatch));
    }
    return res;
};
exports.getMriOptions = (options) => {
    const result = { alias: {}, boolean: [] };
    for (const [index, option] of options.entries()) {
        // We do not set default values in mri options
        // Since its type (typeof) will be used to cast parsed arguments.
        // Which mean `--foo foo` will be parsed as `{foo: true}` if we have `{default:{foo: true}}`
        // Set alias
        if (option.names.length > 1) {
            result.alias[option.names[0]] = option.names.slice(1);
        }
        // Set boolean
        if (option.isBoolean) {
            if (option.negated) {
                // For negated option
                // We only set it to `boolean` type when there's no string-type option with the same name
                const hasStringTypeOption = options.some((o, i) => {
                    return (i !== index &&
                        o.names.some(name => option.names.includes(name)) &&
                        typeof o.required === 'boolean');
                });
                if (!hasStringTypeOption) {
                    result.boolean.push(option.names[0]);
                }
            }
            else {
                result.boolean.push(option.names[0]);
            }
        }
    }
    return result;
};
exports.findLongest = (arr) => {
    return arr.sort((a, b) => {
        return a.length > b.length ? -1 : 1;
    })[0];
};
exports.padRight = (str, length) => {
    return str.length >= length ? str : `${str}${' '.repeat(length - str.length)}`;
};
exports.camelcase = (input) => {
    return input.replace(/([a-z])-([a-z])/g, (_, p1, p2) => {
        return p1 + p2.toUpperCase();
    });
};
exports.setDotProp = (obj, keys, val) => {
    let i = 0;
    let length = keys.length;
    let t = obj;
    let x;
    for (; i < length; ++i) {
        x = t[keys[i]];
        t = t[keys[i]] =
            i === length - 1
                ? val
                : x != null
                    ? x
                    : !!~keys[i + 1].indexOf('.') || !(+keys[i + 1] > -1)
                        ? {}
                        : [];
    }
};
exports.setByType = (obj, transforms) => {
    for (const key of Object.keys(transforms)) {
        const transform = transforms[key];
        if (transform.shouldTransform) {
            obj[key] = Array.prototype.concat.call([], obj[key]);
            if (typeof transform.transformFunction === 'function') {
                obj[key] = obj[key].map(transform.transformFunction);
            }
        }
    }
};
});

unwrapExports(utils);
var utils_1 = utils.removeBrackets;
var utils_2 = utils.findAllBrackets;
var utils_3 = utils.getMriOptions;
var utils_4 = utils.findLongest;
var utils_5 = utils.padRight;
var utils_6 = utils.camelcase;
var utils_7 = utils.setDotProp;
var utils_8 = utils.setByType;

var Option_1 = createCommonjsModule(function (module, exports) {
Object.defineProperty(exports, "__esModule", { value: true });

class Option {
    constructor(rawName, description, config) {
        this.rawName = rawName;
        this.description = description;
        this.config = Object.assign({}, config);
        // You may use cli.option('--env.* [value]', 'desc') to denote a dot-nested option
        rawName = rawName.replace(/\.\*/g, '');
        this.negated = false;
        this.names = utils.removeBrackets(rawName)
            .split(',')
            .map((v) => {
            let name = v.trim().replace(/^-{1,2}/, '');
            if (name.startsWith('no-')) {
                this.negated = true;
                name = name.replace(/^no-/, '');
            }
            return name;
        })
            .sort((a, b) => (a.length > b.length ? 1 : -1)); // Sort names
        // Use the longese name (last one) as actual option name
        this.name = this.names[this.names.length - 1];
        if (this.negated) {
            this.config.default = true;
        }
        if (rawName.includes('<')) {
            this.required = true;
        }
        else if (rawName.includes('[')) {
            this.required = false;
        }
        else {
            // No arg needed, it's boolean flag
            this.isBoolean = true;
        }
    }
}
exports.default = Option;
});

unwrapExports(Option_1);

var Command_1 = createCommonjsModule(function (module, exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const Option_1$$1 = __importDefault(Option_1);

class Command {
    constructor(rawName, description, config = {}, cli) {
        this.rawName = rawName;
        this.description = description;
        this.config = config;
        this.cli = cli;
        this.options = [];
        this.aliasNames = [];
        this.name = utils.removeBrackets(rawName);
        this.args = utils.findAllBrackets(rawName);
        this.examples = [];
    }
    usage(text) {
        this.usageText = text;
        return this;
    }
    allowUnknownOptions() {
        this.config.allowUnknownOptions = true;
        return this;
    }
    ignoreOptionDefaultValue() {
        this.config.ignoreOptionDefaultValue = true;
        return this;
    }
    version(version, customFlags = '-v, --version') {
        this.versionNumber = version;
        this.option(customFlags, 'Display version number');
        return this;
    }
    example(example) {
        this.examples.push(example);
        return this;
    }
    /**
     * Add a option for this command
     * @param rawName Raw option name(s)
     * @param description Option description
     * @param config Option config
     */
    option(rawName, description, config) {
        const option = new Option_1$$1.default(rawName, description, config);
        this.options.push(option);
        return this;
    }
    alias(name) {
        this.aliasNames.push(name);
        return this;
    }
    action(callback) {
        this.commandAction = callback;
        return this;
    }
    /**
     * Check if a command name is matched by this command
     * @param name Command name
     */
    isMatched(name) {
        return this.name === name || this.aliasNames.includes(name);
    }
    get isDefaultCommand() {
        return this.name === '' || this.aliasNames.includes('!');
    }
    get isGlobalCommand() {
        return this instanceof GlobalCommand;
    }
    /**
     * Check if an option is registered in this command
     * @param name Option name
     */
    hasOption(name) {
        name = name.split('.')[0];
        return this.options.find(option => {
            return option.names.includes(name);
        });
    }
    outputHelp() {
        const { name, commands } = this.cli;
        const { versionNumber, options: globalOptions, helpCallback } = this.cli.globalCommand;
        const sections = [
            {
                body: `${name}${versionNumber ? ` v${versionNumber}` : ''}`
            }
        ];
        sections.push({
            title: 'Usage',
            body: `  $ ${name} ${this.usageText || this.rawName}`
        });
        const showCommands = (this.isGlobalCommand || this.isDefaultCommand) && commands.length > 0;
        if (showCommands) {
            const longestCommandName = utils.findLongest(commands.map(command => command.rawName));
            sections.push({
                title: 'Commands',
                body: commands
                    .map(command => {
                    return `  ${utils.padRight(command.rawName, longestCommandName.length)}  ${command.description}`;
                })
                    .join('\n')
            });
            sections.push({
                title: `For more info, run any command with the \`--help\` flag`,
                body: commands
                    .map(command => `  $ ${name}${command.name === '' ? '' : ` ${command.name}`} --help`)
                    .join('\n')
            });
        }
        const options = this.isGlobalCommand
            ? globalOptions
            : [...this.options, ...(globalOptions || [])];
        if (options.length > 0) {
            const longestOptionName = utils.findLongest(options.map(option => option.rawName));
            sections.push({
                title: 'Options',
                body: options
                    .map(option => {
                    return `  ${utils.padRight(option.rawName, longestOptionName.length)}  ${option.description} ${option.config.default === undefined
                        ? ''
                        : `(default: ${option.config.default})`}`;
                })
                    .join('\n')
            });
        }
        if (this.examples.length > 0) {
            sections.push({
                title: 'Examples',
                body: this.examples
                    .map(example => {
                    if (typeof example === 'function') {
                        return example(name);
                    }
                    return example;
                })
                    .join('\n')
            });
        }
        if (helpCallback) {
            helpCallback(sections);
        }
        console.log(sections
            .map(section => {
            return section.title
                ? `${section.title}:\n${section.body}`
                : section.body;
        })
            .join('\n\n'));
        process.exit(0);
    }
    outputVersion() {
        const { name } = this.cli;
        const { versionNumber } = this.cli.globalCommand;
        if (versionNumber) {
            console.log(`${name}/${versionNumber} ${process.platform}-${process.arch} node-${process.version}`);
        }
        process.exit(0);
    }
    checkRequiredArgs() {
        const minimalArgsCount = this.args.filter(arg => arg.required).length;
        if (this.cli.args.length < minimalArgsCount) {
            console.error(`error: missing required args for command \`${this.rawName}\``);
            process.exit(1);
        }
    }
    /**
     * Check if the parsed options contain any unknown options
     *
     * Exit and output error when true
     */
    checkUnknownOptions() {
        const { rawOptions, globalCommand } = this.cli;
        if (!this.config.allowUnknownOptions) {
            for (const name of Object.keys(rawOptions)) {
                if (name !== '--' &&
                    !this.hasOption(name) &&
                    !globalCommand.hasOption(name)) {
                    console.error(`error: Unknown option \`${name.length > 1 ? `--${name}` : `-${name}`}\``);
                    process.exit(1);
                }
            }
        }
    }
    /**
     * Check if the required string-type options exist
     */
    checkOptionValue() {
        const { rawOptions, globalCommand } = this.cli;
        const options = [...globalCommand.options, ...this.options];
        for (const option of options) {
            const value = rawOptions[option.name.split('.')[0]];
            // Check required option value
            if (option.required) {
                const hasNegated = options.some(o => o.negated && o.names.includes(option.name));
                if (value === true || (value === false && !hasNegated)) {
                    console.error(`error: option \`${option.rawName}\` value is missing`);
                    process.exit(1);
                }
            }
        }
    }
}
class GlobalCommand extends Command {
    constructor(cli) {
        super('@@global@@', '', {}, cli);
    }
}
exports.GlobalCommand = GlobalCommand;
exports.default = Command;
});

unwrapExports(Command_1);
var Command_2 = Command_1.GlobalCommand;

var CAC_1 = createCommonjsModule(function (module, exports) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (commonjsGlobal && commonjsGlobal.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });

const path_1 = __importDefault(path);
const mri_1 = __importDefault(lib);
const Command_1$$1 = __importStar(Command_1);

class CAC extends events.EventEmitter {
    /**
     * @param name The program name to display in help and version message
     */
    constructor(name = '') {
        super();
        this.name = name;
        this.commands = [];
        this.globalCommand = new Command_1$$1.GlobalCommand(this);
        this.globalCommand.usage('<command> [options]');
    }
    /**
     * Add a global usage text.
     *
     * This is not used by sub-commands.
     */
    usage(text) {
        this.globalCommand.usage(text);
        return this;
    }
    /**
     * Add a sub-command
     */
    command(rawName, description, config) {
        const command = new Command_1$$1.default(rawName, description || '', config, this);
        command.globalCommand = this.globalCommand;
        this.commands.push(command);
        return command;
    }
    /**
     * Add a global CLI option.
     *
     * Which is also applied to sub-commands.
     */
    option(rawName, description, config) {
        this.globalCommand.option(rawName, description, config);
        return this;
    }
    /**
     * Show help message when `-h, --help` flags appear.
     *
     */
    help(callback) {
        this.globalCommand.option('-h, --help', 'Display this message');
        this.globalCommand.helpCallback = callback;
        this.showHelpOnExit = true;
        return this;
    }
    /**
     * Show version number when `-v, --version` flags appear.
     *
     */
    version(version, customFlags = '-v, --version') {
        this.globalCommand.version(version, customFlags);
        this.showVersionOnExit = true;
        return this;
    }
    /**
     * Add a global example.
     *
     * This example added here will not be used by sub-commands.
     */
    example(example) {
        this.globalCommand.example(example);
        return this;
    }
    /**
     * Output the corresponding help message
     * When a sub-command is matched, output the help message for the command
     * Otherwise output the global one.
     *
     * This will also call `process.exit(0)` to quit the process.
     */
    outputHelp() {
        if (this.matchedCommand) {
            this.matchedCommand.outputHelp();
        }
        else {
            this.globalCommand.outputHelp();
        }
    }
    /**
     * Output the version number.
     *
     * This will also call `process.exit(0)` to quit the process.
     */
    outputVersion() {
        this.globalCommand.outputVersion();
    }
    setParsedInfo({ args, options, rawOptions }, matchedCommand) {
        this.args = args;
        this.options = options;
        this.rawOptions = rawOptions;
        if (matchedCommand) {
            this.matchedCommand = matchedCommand;
        }
        return this;
    }
    /**
     * Parse argv
     */
    parse(argv = process.argv, { 
    /** Whether to run the action for matched command */
    run = true } = {}) {
        this.rawArgs = argv;
        if (!this.name) {
            this.name = argv[1] ? path_1.default.basename(argv[1]) : 'cli';
        }
        let shouldParse = true;
        // Search sub-commands
        for (const command of this.commands) {
            const mriResult = this.mri(argv.slice(2), command);
            const commandName = mriResult.args[0];
            if (command.isMatched(commandName)) {
                shouldParse = false;
                const parsedInfo = Object.assign({}, mriResult, { args: mriResult.args.slice(1) });
                this.setParsedInfo(parsedInfo, command);
                this.emit(`command:${commandName}`, command);
            }
        }
        if (shouldParse) {
            // Search the default command
            for (const command of this.commands) {
                if (command.name === '') {
                    shouldParse = false;
                    const mriResult = this.mri(argv.slice(2), command);
                    this.setParsedInfo(mriResult, command);
                    this.emit(`command:!`, command);
                }
            }
        }
        if (shouldParse) {
            const mriResult = this.mri(argv.slice(2));
            this.setParsedInfo(mriResult);
        }
        if (this.options.help && this.showHelpOnExit) {
            this.outputHelp();
        }
        if (this.options.version && this.showVersionOnExit) {
            this.outputVersion();
        }
        const parsedArgv = { args: this.args, options: this.options };
        if (run) {
            this.runMatchedCommand();
        }
        if (!this.matchedCommand && this.args[0]) {
            this.emit('command:*');
        }
        return parsedArgv;
    }
    mri(argv, 
    /** Matched command */ command) {
        // All added options
        const cliOptions = [
            ...this.globalCommand.options,
            ...(command ? command.options : [])
        ];
        const mriOptions = utils.getMriOptions(cliOptions);
        // Extract everything after `--` since mri doesn't support it
        let argsAfterDoubleDashes = [];
        const doubleDashesIndex = argv.indexOf('--');
        if (doubleDashesIndex > -1) {
            argsAfterDoubleDashes = argv.slice(doubleDashesIndex + 1);
            argv = argv.slice(0, doubleDashesIndex);
        }
        const parsed = mri_1.default(argv, mriOptions);
        const args = parsed._;
        delete parsed._;
        const options = {
            '--': argsAfterDoubleDashes
        };
        // Set option default value
        const ignoreDefault = command && command.config.ignoreOptionDefaultValue
            ? command.config.ignoreOptionDefaultValue
            : this.globalCommand.config.ignoreOptionDefaultValue;
        let transforms = Object.create(null);
        for (const cliOption of cliOptions) {
            if (!ignoreDefault && cliOption.config.default !== undefined) {
                for (const name of cliOption.names) {
                    options[name] = cliOption.config.default;
                }
            }
            // If options type is defined
            if (Array.isArray(cliOption.config.type)) {
                if (transforms[cliOption.name] === undefined) {
                    transforms[cliOption.name] = Object.create(null);
                    transforms[cliOption.name]['shouldTransform'] = true;
                    transforms[cliOption.name]['transformFunction'] =
                        cliOption.config.type[0];
                }
            }
        }
        // Camelcase option names and set dot nested option values
        for (const key of Object.keys(parsed)) {
            const keys = key.split('.').map((v, i) => {
                return i === 0 ? utils.camelcase(v) : v;
            });
            utils.setDotProp(options, keys, parsed[key]);
            utils.setByType(options, transforms);
        }
        return {
            args,
            options,
            rawOptions: parsed
        };
    }
    runMatchedCommand() {
        const { args, options, matchedCommand: command } = this;
        if (!command || !command.commandAction)
            return;
        command.checkUnknownOptions();
        command.checkOptionValue();
        command.checkRequiredArgs();
        const actionArgs = [];
        command.args.forEach((arg, index) => {
            if (arg.variadic) {
                actionArgs.push(args.slice(index));
            }
            else {
                actionArgs.push(args[index]);
            }
        });
        actionArgs.push(options);
        return command.commandAction.apply(this, actionArgs);
    }
}
exports.default = CAC;
});

unwrapExports(CAC_1);

var lib$1 = createCommonjsModule(function (module) {
var __importDefault = (commonjsGlobal && commonjsGlobal.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
const CAC_1$$1 = __importDefault(CAC_1);
/**
 * @param name The program name to display in help and version message
 */
const cac = (name = '') => new CAC_1$$1.default(name);
module.exports = cac;
});

var index = unwrapExports(lib$1);

module.exports = index;
